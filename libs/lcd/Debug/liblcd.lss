In archive liblcd.a:

lcd.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000da  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000010e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00000000  00000000  0000010e  2**0
                  ALLOC
  3 .stab         000005c4  00000000  00000000  00000110  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000860  00000000  00000000  000006d4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <LCD>:
//-------------------------------------------------------- Start
#include "lcd.h"

void LCD(char ch) {
	DPORT = ch; //Put values to ports
   0:	8b bb       	out	0x1b, r24	; 27
	CPORT = (1 << RS) | (1 << EN); //Signaling to send data
   2:	80 ea       	ldi	r24, 0xA0	; 160
   4:	85 bb       	out	0x15, r24	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   6:	85 e3       	ldi	r24, 0x35	; 53
   8:	8a 95       	dec	r24
   a:	01 f4       	brne	.+0      	; 0xc <LCD+0xc>
   c:	00 00       	nop
	_delay_us(10);
	CPORT = (1 << RS) | (0 << EN);
   e:	80 e2       	ldi	r24, 0x20	; 32
  10:	85 bb       	out	0x15, r24	; 21
  12:	80 ef       	ldi	r24, 0xF0	; 240
  14:	8a 95       	dec	r24
  16:	01 f4       	brne	.+0      	; 0x18 <LCD+0x18>
	_delay_us(45);
}
  18:	08 95       	ret

0000001a <LCD_cmd>:

void LCD_cmd(char ch) {
	DPORT = ch;
  1a:	8b bb       	out	0x1b, r24	; 27
	CPORT = (0 << RS) | (1 << EN); //Signaling to send commands
  1c:	90 e8       	ldi	r25, 0x80	; 128
  1e:	95 bb       	out	0x15, r25	; 21
  20:	95 e3       	ldi	r25, 0x35	; 53
  22:	9a 95       	dec	r25
  24:	01 f4       	brne	.+0      	; 0x26 <LCD_cmd+0xc>
  26:	00 00       	nop
	_delay_us(10);
	CPORT = (0 << RS) | (0 << EN);
  28:	15 ba       	out	0x15, r1	; 21
  2a:	90 ef       	ldi	r25, 0xF0	; 240
  2c:	9a 95       	dec	r25
  2e:	01 f4       	brne	.+0      	; 0x30 <LCD_cmd+0x16>
	_delay_us(45);
	if (ch == 0x01 || ch == 0x02)
  30:	81 50       	subi	r24, 0x01	; 1
  32:	82 30       	cpi	r24, 0x02	; 2
  34:	00 f4       	brcc	.+0      	; 0x36 <LCD_cmd+0x1c>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  36:	8f e3       	ldi	r24, 0x3F	; 63
  38:	9f e1       	ldi	r25, 0x1F	; 31
  3a:	01 97       	sbiw	r24, 0x01	; 1
  3c:	01 f4       	brne	.+0      	; 0x3e <LCD_cmd+0x24>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <LCD_cmd+0x26>
  40:	00 00       	nop
  42:	08 95       	ret

00000044 <LCD_init>:

}

void LCD_init(void) {

	DPDDR = 0xff;
  44:	8f ef       	ldi	r24, 0xFF	; 255
  46:	8a bb       	out	0x1a, r24	; 26
	CPDDR = 0xf0;
  48:	80 ef       	ldi	r24, 0xF0	; 240
  4a:	84 bb       	out	0x14, r24	; 20

	LCD_cmd(LCD8bit);
  4c:	88 e3       	ldi	r24, 0x38	; 56
  4e:	0e 94 00 00 	call	0	; 0x0 <LCD>
	LCD_cmd(LCDCursorOn);
  52:	8f e0       	ldi	r24, 0x0F	; 15
  54:	0e 94 00 00 	call	0	; 0x0 <LCD>
	LCD_cmd(LCDClear);
  58:	81 e0       	ldi	r24, 0x01	; 1
  5a:	0e 94 00 00 	call	0	; 0x0 <LCD>
	LCD_cmd(LCDSeek00);
  5e:	80 e8       	ldi	r24, 0x80	; 128
  60:	0e 94 00 00 	call	0	; 0x0 <LCD>
}
  64:	08 95       	ret

00000066 <LCD_printStr>:

void LCD_printStr(char *str) {
  66:	ef 92       	push	r14
  68:	ff 92       	push	r15
  6a:	cf 93       	push	r28
  6c:	df 93       	push	r29
  6e:	e8 2e       	mov	r14, r24
  70:	e7 01       	movw	r28, r14
  72:	7e 01       	movw	r14, r28
  74:	f9 2e       	mov	r15, r25
  76:	e7 01       	movw	r28, r14
	int i = 0;
	while (str[i] != '\0') {
  78:	00 c0       	rjmp	.+0      	; 0x7a <LCD_printStr+0x14>
		DPORT = str[i]; //Put values to ports
  7a:	8b bb       	out	0x1b, r24	; 27
  7c:	21 96       	adiw	r28, 0x01	; 1
		LCD(str[i]);
  7e:	80 81       	ld	r24, Z
  80:	0e 94 00 00 	call	0	; 0x0 <LCD>
	LCD_cmd(LCDCursorOn);
	LCD_cmd(LCDClear);
	LCD_cmd(LCDSeek00);
}

void LCD_printStr(char *str) {
  84:	fe 01       	movw	r30, r28
	int i = 0;
	while (str[i] != '\0') {
  86:	88 81       	ld	r24, Y
  88:	88 23       	and	r24, r24
  8a:	01 f4       	brne	.+0      	; 0x8c <LCD_printStr+0x26>
		DPORT = str[i]; //Put values to ports
		LCD(str[i]);
		i++;
	}
}
  8c:	df 91       	pop	r29
  8e:	cf 91       	pop	r28
  90:	ff 90       	pop	r15
  92:	ef 90       	pop	r14
  94:	08 95       	ret

00000096 <LCD_printInt>:
int LCD_printInt(unsigned int i) {
  96:	1f 93       	push	r17
	static int a;
	a = 0;
  98:	10 92 00 00 	sts	0x0000, r1
  9c:	10 92 00 00 	sts	0x0000, r1
	if (i != 0) {
  a0:	00 97       	sbiw	r24, 0x00	; 0
  a2:	01 f0       	breq	.+0      	; 0xa4 <LCD_printInt+0xe>
		LCD_printInt(i / 10);
  a4:	6a e0       	ldi	r22, 0x0A	; 10
  a6:	70 e0       	ldi	r23, 0x00	; 0
  a8:	0e 94 00 00 	call	0	; 0x0 <LCD>
  ac:	18 2f       	mov	r17, r24
  ae:	cb 01       	movw	r24, r22
  b0:	0e 94 00 00 	call	0	; 0x0 <LCD>
		LCD('0' +i % 10);
  b4:	81 2f       	mov	r24, r17
  b6:	80 5d       	subi	r24, 0xD0	; 208
  b8:	0e 94 00 00 	call	0	; 0x0 <LCD>
		a++;
  bc:	80 91 00 00 	lds	r24, 0x0000
  c0:	90 91 00 00 	lds	r25, 0x0000
  c4:	01 96       	adiw	r24, 0x01	; 1
  c6:	90 93 00 00 	sts	0x0000, r25
  ca:	80 93 00 00 	sts	0x0000, r24
	}
	return a;
}
  ce:	80 91 00 00 	lds	r24, 0x0000
  d2:	90 91 00 00 	lds	r25, 0x0000
  d6:	1f 91       	pop	r17
  d8:	08 95       	ret
